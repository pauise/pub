<!DOCTYPE html>
<html>
   <head>
      <!-- Test Github URL 
      https://htmlpreview.github.io/?https://raw.githubusercontent.com/pauise/pub/refs/heads/main/routes/shared/viewer/viewer.html
      -->
      <script language="Javascript">
         function getCookie(name) {
                // 1. Prepare the name to look for (e.g., "stage=")
                let nameEQ = name + "=";
                // 2. Split all cookies into an array
                let ca = document.cookie.split(';');
                
                for (let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    // 3. Remove leading spaces
                    while (c.charAt(0) === ' ') {
                        c = c.substring(1, c.length);
                    }
                    // 4. If this cookie starts with the name, return the value
                    if (c.indexOf(nameEQ) === 0) {
                        return c.substring(nameEQ.length, c.length);
                    }
                }
                return null; // Return null if the cookie isn't found
            }

         // Usage:
         // const currentStage = getCookie("stage");
         // console.log("The value of stage is:", currentStage);


         /**
          * Writes a cookie with customizable options.
          * @param {string} name - The name of the cookie (Required)
          * @param {string|number} value - The value to store (Required)
          * @param {number} daysToLive - Days until expiration (Default: 7)
          * @param {string} path - URL path accessibility (Default: "/")
          * @param {string} sameSite - Security attribute (Default: "Lax")
          */
         function setCookie(name, value, daysToLive = 7, path = "/", sameSite = "Lax") {
             // 1. Calculate the expiration date
             const date = new Date();
             date.setTime(date.getTime() + (daysToLive * 24 * 60 * 60 * 1000));
             const expires = "expires=" + date.toUTCString();
         
             // 2. Construct the cookie string
             // EncodeURIComponent ensures special characters in the value don't break the cookie
             document.cookie = `${name}=${encodeURIComponent(value)}; ${expires}; path=${path}; SameSite=${sameSite}`;
             //console.log(`Cookie '${name}' set for ${daysToLive} days.`);
         }

         /**
          * Retrieves a JSON file and parses it into an object.
          * @param {string} url - The path or URL to the JSON file.
          */
         async function getJson(url) {
             try {
                 const response = await fetch(url);
         
                 // Check if the request was successful (status 200-299)
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
         
                 // Parse the body as a JSON object
                 const data = await response.json();
                 
                 console.log("JSON data received:", data);
                 return data;
             } catch (error) {
                 console.error("Error fetching or parsing JSON:", error);
             }
         }

         // Usage:
         /*getJson('https://api.example.com/user/1')
             .then(data => {
                 if (data) {
                     console.log(data.name); // Access properties directly
                 }
             });*/

         /**
          * Retrieves a GPX file and parses it into an XML Document.
          * @param {string} url - The path to the .gpx file.
          */
         async function getGpxAsXml(url) {
             try {
                 const response = await fetch(url);
         
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
         
                 // 1. Get the data as a raw string
                 const gpxString = await response.text();
         
                 // 2. Initialize the parser
                 const parser = new DOMParser();
         
                 // 3. Parse the string into an XML Document
                 const xmlDoc = parser.parseFromString(gpxString, "application/xml");
         
                 // 4. Check for parsing errors
                 const errorNode = xmlDoc.querySelector('parsererror');
                 if (errorNode) {
                     throw new Error("Error parsing XML");
                 }
         
                 return xmlDoc;
             } catch (error) {
                 console.error("Failed to fetch or parse GPX:", error);
             }
         }
         
         // Usage:
         /*getGpxAsXml('path/to/route.gpx').then(xml => {
             if (xml) {
                 // Example: Get all track points
                 const trackPoints = xml.getElementsByTagName("trkpt");
                 console.log(`Found ${trackPoints.length} track points.`);
                 
                 // Example: Read latitude of the first point
                 console.log("First lat:", trackPoints[0].getAttribute("lat"));
             }
         });*/

         function downloadGeneratedHTML(fileName = "hardcopy.html") {
             // 1. Get the current state of the entire HTML document
             // Using document.documentElement.outerHTML captures from <html> to </html>
             const currentHTML = document.documentElement.outerHTML;
         
             // 2. Create a Blob containing the HTML string
             const blob = new Blob([currentHTML], { type: 'text/html' });
         
             // 3. Create a temporary "anchor" element to trigger the download
             const link = document.createElement('a');
             link.href = URL.createObjectURL(blob);
             link.download = fileName;
         
             // 4. Programmatically click the link and then remove it
             document.body.appendChild(link);
             link.click();
             document.body.removeChild(link);
             
             // Clean up the URL object to save memory
             URL.revokeObjectURL(link.href);
         }
         
         // Usage:
         // You can call this after your dynamic generation logic is finished
         // downloadGeneratedHTML('my-dynamic-page.html');

         
      </script>
   </head>
<body>

<h1>SVG Viewer</h1>

<svg width="1000" height="500" xmlns="http://www.w3.org/2000/svg">
  <!-- Style -->
  <style>
    /* <![CDATA[ */
    .pr-line { stroke: #AD00AD; stroke-width: 2; stroke-dasharray: 2,2}
    .pr-circle { fill: pink; }
    .pr-arch { fill: #AD00AD; }
    .pr-text { stroke: #AD00AD; font-family: Monospace; font-size: 14; text-anchor: middle}
      
    .wp-line { stroke: #0000dd; stroke-width: 2; stroke-dasharray: 2,2}
    .wp-circle { fill: #0000dd; stroke-width: 1; stroke: black; }
    .wp-text { stroke: white; font-family: Monospace; font-size: 12; font-weight: black; text-anchor: middle; dominant-baseline: central}
    /* ]]> */
  </style>

   <defs>
     <!-- Escacs -->
     <pattern id="escacs" x="0" y="0" width="10" height="10" patternUnits="userSpaceOnUse">
       <rect x="0" y="0" width="10" height="10" fill="white" />
       <rect x="0" y="0" width="5" height="5" fill="black" />
       <rect x="5" y="5" width="5" height="5" fill="black" />
     </pattern>
     
     <!-- Stage portions --> 
     <g id="pr25">
        <line x1="0" y1="0" x2="0" y2="400" class="pr-line" />
        <circle rx="0" cy="0" r="16" class="pr-circle" />
        <path d="M 0 0
          L 0 -16 
          A 16 16 0 0 1 16 0
          Z" 
          class="pr-arch" />
     </g>
     <g id="pr50">
        <line x1="0" y1="0" x2="0" y2="400" class="pr-line" />
        <circle rx="0" cy="0" r="16" class="pr-circle" />
        <path d="M 0 0
          L 0 -16 
          A 16 16 0 1 1 0 16
          Z" 
          class="pr-arch" />
     </g>
     <g id="pr75">
        <line x1="0" y1="0" x2="0" y2="400" class="pr-line" />
        <circle rx="0" cy="0" r="16" class="pr-circle" />
        <path d="M 0 0
          L 0 -16 
          A 16 16 0 1 1 -16 0
          Z" 
          class="pr-arch" />
     </g>

     <!-- Waypoint -->
     <g id="wp">
       <line x1="0" y1="0" x2="0" y2="350" class="wp-line" />
       <path d="M -10 0
         A 5 5 0 0 1 10 0
         L 0 20 
         Z" 
         class="wp-circle" />
     </g>
   </defs>
   
   <!-- Stage portion 350,100 -->
   <use href="#pr25" x="350" y="80" />
   <text x="350" y="62" class="pr-text">1h47'</text>
   <use href="#pr50" x="400" y="80" />
   <text x="400" y="62" class="pr-text">3h05'</text>
   <use href="#pr75" x="450" y="80" />
   <text x="450" y="62" class="pr-text">4h58'</text>
   
   <!-- Waypoint 250,150-->
   <use href="#wp" x="250" y="150" />
   <!--line x1="250" y1="150" x2="250" y2="300" class="wp-line" />
   <circle cx="250" cy="150" r="10" class="wp-circle" /-->
   <text x="250" y="150" class="wp-text">27</text>

   <!-- Gràfic principal -->
   <!-- Eliminem linia superior : line x1="95" y1="10" x2="1000" y2="10" stroke="black" stroke-width="1" /-->
   <line x1="95" y1="480" x2="980" y2="480" stroke="black" stroke-width="1" />
   <line x1="100" y1="20" x2="100" y2="485" stroke="black" stroke-width="1" />
   <line x1="980" y1="20" x2="980" y2="485" stroke="black" stroke-width="1" />
   <text x="90" y="480" font-family="Monospace" fill="black" font-size="12" font-weight="black" text-anchor="end">0</text>

   <!-- Sortida -->
   <circle cx="100" cy="20" r="16" fill="#404040" stroke="black" stroke-width="1" />
   <path d="M 92 12 
            L 92 28 
            L 108 20
            Z" 
         fill="lime" />
   <text x="120" y="36" font-family="Impact" fill="black" font-size="16" text-anchor="start">Vinaròs</text>
   <text x="100" y="500" fill="black" font-size="12" font-weight="black" text-anchor="middle">0</text>
   <!-- Meta -->
   <circle cx="980" cy="20" r="16" fill="url(#escacs)" stroke="black" stroke-width="1" />
   <text x="960" y="36" font-family="Impact" fill="black" font-size="16" text-anchor="end">Ulldecona</text>
   <text x="980" y="500" fill="black" font-size="12" font-weight="black" text-anchor="middle">14.7</text>
   
   <!-- Marques verticals -->
   <!-- line x1="95" y1="10" x2="1000" y2="10" stroke="black" stroke-width="1" /-->
      
   
   Sorry, your browser does not support inline SVG.
</svg> 
 
</body>
</html>
<!--
Notes
=====
Dades: Per construir el gràfic s'ha de coneixer l'alçada màxima, la mínima i els kms
Dimensions: Fixes, 240 alt x 400 ample
Marques horitzontals: 
   - Sempre entre les mínimes i les 20 marques màxim
   - Les marques seran generalment d'1km, excepte que la ruta sigui molt llarga; 
      Fins a 20 kms, 1 km/marca, més de 20; 2 kms/marca... de 40; 5 k/m... de 100; 10... de 200; 20... de 400; 50... de 1000;100.
      x_escala_rules = [ {"fins_km": 20; "km_per_marca": 1}, {"fins_km": 40; "km_per_marca": 2}, {"fins_km": 100; "km_per_marca": 5}, ... ]
Etiquetes horitzontals: 
   - Sempre es marcarà el 0 i l'últim km. 
   - Si l'últim km pot tapar l'anterior punt km, llavors no es posa l'anterior
   - La resta de punts km es posen o bé
Marques verticals:
   - Sempre entre les 6 i les 10 marques màxim
   - Sempre es deixarà una cota sencera per sota l'alçada mínima i 4 per sobre de la màxima
   - Dit d'una altra manera, la gràfica transcorrerà entre el 5% i el 55% de la graella. La resta són marge 0-5% i 95-100%, waypoints 55-75% i per parcials d'etapa 75-95%
   - Per tant, si alçada màxima - mínima = alt_diff_perfil ; alt_escala = 2 x alt_diff_perfil
   - Ara bé, hi haurà una alt_escala mínima; ja que si la alt_diff_perfil és baixa per ser etapa plana, no dibuixarem puntes en una etapa plana
      Fins a 125m diff, 25m/marca. Fins a 250m diff, 50m/marca. Fins a 500, 100. Fins a 1000, 200. Fins a 2000, 400. Fins a 5000, 1000.

-->
