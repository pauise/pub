<!DOCTYPE html>
<html>
   <head>
      <!-- Test Github URL 
      https://htmlpreview.github.io/?https://raw.githubusercontent.com/pauise/pub/refs/heads/main/routes/shared/viewer/viewer.html
      -->
      <script language="Javascript">
         function getCookie(name) {
                // 1. Prepare the name to look for (e.g., "stage=")
                let nameEQ = name + "=";
                // 2. Split all cookies into an array
                let ca = document.cookie.split(';');
                
                for (let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    // 3. Remove leading spaces
                    while (c.charAt(0) === ' ') {
                        c = c.substring(1, c.length);
                    }
                    // 4. If this cookie starts with the name, return the value
                    if (c.indexOf(nameEQ) === 0) {
                        return c.substring(nameEQ.length, c.length);
                    }
                }
                return null; // Return null if the cookie isn't found
            }

         // Usage:
         // const currentStage = getCookie("stage");
         // console.log("The value of stage is:", currentStage);


         /**
          * Writes a cookie with customizable options.
          * @param {string} name - The name of the cookie (Required)
          * @param {string|number} value - The value to store (Required)
          * @param {number} daysToLive - Days until expiration (Default: 7)
          * @param {string} path - URL path accessibility (Default: "/")
          * @param {string} sameSite - Security attribute (Default: "Lax")
          */
         function setCookie(name, value, daysToLive = 7, path = "/", sameSite = "Lax") {
             // 1. Calculate the expiration date
             const date = new Date();
             date.setTime(date.getTime() + (daysToLive * 24 * 60 * 60 * 1000));
             const expires = "expires=" + date.toUTCString();
         
             // 2. Construct the cookie string
             // EncodeURIComponent ensures special characters in the value don't break the cookie
             document.cookie = `${name}=${encodeURIComponent(value)}; ${expires}; path=${path}; SameSite=${sameSite}`;
             //console.log(`Cookie '${name}' set for ${daysToLive} days.`);
         }

         /**
          * Retrieves a JSON file and parses it into an object.
          * @param {string} url - The path or URL to the JSON file.
          */
         async function getJson(url) {
             try {
                 const response = await fetch(url);
         
                 // Check if the request was successful (status 200-299)
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
         
                 // Parse the body as a JSON object
                 const data = await response.json();
                 
                 console.log("JSON data received:", data);
                 return data;
             } catch (error) {
                 console.error("Error fetching or parsing JSON:", error);
             }
         }

         // Usage:
         /*getJson('https://api.example.com/user/1')
             .then(data => {
                 if (data) {
                     console.log(data.name); // Access properties directly
                 }
             });*/

         /**
          * Retrieves a GPX file and parses it into an XML Document.
          * @param {string} url - The path to the .gpx file.
          */
         async function getGpxAsXml(url) {
             try {
                 const response = await fetch(url);
         
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
         
                 // 1. Get the data as a raw string
                 const gpxString = await response.text();
         
                 // 2. Initialize the parser
                 const parser = new DOMParser();
         
                 // 3. Parse the string into an XML Document
                 const xmlDoc = parser.parseFromString(gpxString, "application/xml");
         
                 // 4. Check for parsing errors
                 const errorNode = xmlDoc.querySelector('parsererror');
                 if (errorNode) {
                     throw new Error("Error parsing XML");
                 }
         
                 return xmlDoc;
             } catch (error) {
                 console.error("Failed to fetch or parse GPX:", error);
             }
         }
         
         // Usage:
         /*getGpxAsXml('path/to/route.gpx').then(xml => {
             if (xml) {
                 // Example: Get all track points
                 const trackPoints = xml.getElementsByTagName("trkpt");
                 console.log(`Found ${trackPoints.length} track points.`);
                 
                 // Example: Read latitude of the first point
                 console.log("First lat:", trackPoints[0].getAttribute("lat"));
             }
         });*/

         function downloadGeneratedHTML(fileName = "hardcopy.html") {
             // 1. Get the current state of the entire HTML document
             // Using document.documentElement.outerHTML captures from <html> to </html>
             const currentHTML = document.documentElement.outerHTML;
         
             // 2. Create a Blob containing the HTML string
             const blob = new Blob([currentHTML], { type: 'text/html' });
         
             // 3. Create a temporary "anchor" element to trigger the download
             const link = document.createElement('a');
             link.href = URL.createObjectURL(blob);
             link.download = fileName;
         
             // 4. Programmatically click the link and then remove it
             document.body.appendChild(link);
             link.click();
             document.body.removeChild(link);
             
             // Clean up the URL object to save memory
             URL.revokeObjectURL(link.href);
         }
         
         // Usage:
         // You can call this after your dynamic generation logic is finished
         // downloadGeneratedHTML('my-dynamic-page.html');

         // nice axis scaling
         function getStrictAltitudeMarks(minAlt, maxAlt, numMarks) {
             const multiples = [10, 15, 20, 25, 30, 40, 50, 100, 150, 200, 250, 300, 400, 500, 1000];
             const range = maxAlt - minAlt;
             
             // Find a starting step based on the range
             let stepIndex = multiples.findIndex(m => m > range / (numMarks - 1));
             if (stepIndex === -1) stepIndex = multiples.length - 1;
         
             let step, startMark, lastMark;
         
             // Iterate through multiples until boundaries are strictly respected
             for (let i = stepIndex; i < multiples.length; i++) {
                 step = multiples[i];
                 
                 // Calculate startMark: must be strictly less than minAlt
                 // If minAlt is 120 and step is 20, we want 100, not 120.
                 startMark = Math.floor(minAlt / step) * step;
                 if (startMark === minAlt) {
                     startMark -= step;
                 }
         
                 lastMark = startMark + (step * (numMarks - 1));
         
                 // Check if maxAlt is strictly less than the last mark
                 if (maxAlt < lastMark) {
                     break; // We found the correct step
                 }
             }
         
             const marks = [];
             for (let i = 0; i < numMarks; i++) {
                 marks.push(startMark + (i * step));
             }
         
             return { step, marks };
         }
         
         // --- Testing with your scenario (120 to 190) ---
         
         console.log("4 Marks:", getStrictAltitudeMarks(120, 190, 4).marks);
         // Result: [100, 150, 200, 250] (120 > 100 and 190 < 250)
         
         console.log("6 Marks:", getStrictAltitudeMarks(120, 190, 6).marks);
         // Result: [100, 120, 140, 160, 180, 200] (120 > 100 and 190 < 200)
         
         console.log("8 Marks:", getStrictAltitudeMarks(120, 190, 8).marks);
         // Result: [110, 125, 140, 155, 170, 185, 200, 215] 
         // Note: If 15 is not in your 'multiples', the logic will jump to step 20.
         
         /* GENERACIÓ HTML :
         <ul id="myList">
            <li>Existing Item 1</li>
         </ul>
         const list = document.querySelector('#myList');
         // This adds the new HTML right before the </ul> closing tag
         if (list) {
            list.insertAdjacentHTML('beforeend', '<li>Success!</li>');
         }
         */
      </script>
   </head>
<body>

<!-- 
Dimensions del SVG x10px: En total són 1200 d'ample per 600 d'alt que es distribuiran:
00-05    6 +From              To+
05-10    5 + Proporcions. Cada pastís fa 16 de radi => 32 de diàmetre i amb el text de 14px amb 1px de separació = 50px; del 50y al 100y.
10-20    4 + WPS; cadascun fa 30, en 100 caben 3 sense solapar-se
20-      3 + PERFIL tindrà un lienz de 1000 d'ample x 360 d'alt
         2 + PERFIL en els 360 d'alt caben 6 marques d'alçada separades per 60px, o 4 de 90px o 8 de 45px .. 10 de 36 ja no massa apretat
  -56    1 + PERFIL
56-57    0 +-+-+-+-+-+-+-+-+-+-+
57-60      0 1 2 3 4 5 6 7 10.12
    0 20 -------------- 120 x10 px
-->
<svg width="1000" height="500" xmlns="http://www.w3.org/2000/svg">
  <!-- Style -->
  <style>
    /* <![CDATA[ */
    .pr-line { stroke: #AD00AD; stroke-width: 2; stroke-dasharray: 2,2}
    .pr-circle { fill: pink; }
    .pr-arch { fill: #AD00AD; }
    .pr-text { stroke: #AD00AD; font-family: Monospace; font-size: 14; text-anchor: middle}
      
    .wp-line { stroke: #0000dd; stroke-width: 2; stroke-dasharray: 2,2}
    .wp-circle { fill: #0000dd; stroke-width: 1; stroke: black; }
    .wp-text { stroke: white; font-family: Monospace; font-size: 12; font-weight: black; text-anchor: middle; dominant-baseline: central}
    /* ]]> */
  </style>

   <defs>
     <!-- Escacs -->
     <pattern id="escacs" x="0" y="0" width="10" height="10" patternUnits="userSpaceOnUse">
       <rect x="0" y="0" width="10" height="10" fill="white" />
       <rect x="0" y="0" width="5" height="5" fill="black" />
       <rect x="5" y="5" width="5" height="5" fill="black" />
     </pattern>
     
     <!-- Stage portions, l'alçada dels pastissos serà sempre la mateixa, 516 enlloc de 400 --> 
     <g id="pr25">
        <line x1="0" y1="0" x2="0" y2="516" class="pr-line" />
        <circle rx="0" cy="0" r="16" class="pr-circle" />
        <path d="M 0 0
          L 0 -16 
          A 16 16 0 0 1 16 0
          Z" 
          class="pr-arch" />
     </g>
     <g id="pr50">
        <line x1="0" y1="0" x2="0" y2="516" class="pr-line" />
        <circle rx="0" cy="0" r="16" class="pr-circle" />
        <path d="M 0 0
          L 0 -16 
          A 16 16 0 1 1 0 16
          Z" 
          class="pr-arch" />
     </g>
     <g id="pr75">
        <line x1="0" y1="0" x2="0" y2="516" class="pr-line" />
        <circle rx="0" cy="0" r="16" class="pr-circle" />
        <path d="M 0 0
          L 0 -16 
          A 16 16 0 1 1 -16 0
          Z" 
          class="pr-arch" />
     </g>

     <!-- Waypoint M=Move, A=Arc i L fa la V 20px més avall del centre del arc junt amb la Z que tanca-->
     <!-- Haurà d'haver un wp1, wp2, wp3 on la linia fins avall serà una o altra perquè estaran a diferents alçades o bé fer la linia a banda a cada cas -->
     <g id="wp">
       <line x1="0" y1="0" x2="0" y2="350" class="wp-line" />
       <path d="M -10 0
         A 5 5 0 0 1 10 0
         L 0 20 
         Z" 
         class="wp-circle" />
     </g>
   </defs>
   
   <!-- Stage portion la seva posició horitzontal pot variar 350,400,450 pero podria ser 500,600,800... -->
   <use href="#pr25" x="350" y="80" />
   <text x="350" y="62" class="pr-text">1h47'</text>
   <use href="#pr50" x="400" y="80" />
   <text x="400" y="62" class="pr-text">3h05'</text>
   <use href="#pr75" x="450" y="80" />
   <text x="450" y="62" class="pr-text">4h58'</text>
   <!-- /*
            // 1. Your list of values
            const values = ["First Value", "Second Value", "Third Value"];
            
            // 2. Select all 3 elements
            const elements = document.querySelectorAll('text.pr-text');
            
            // 3. Loop through the elements and use the 'index' to get the correct value
            elements.forEach((el, index) => {
                // We check if the value exists in our array to avoid errors
                if (values[index] !== undefined) {
                    el.textContent = values[index];
                }
            });


            // 1. Your list of X coordinates
            const xPositions = [100, 250, 400];
            
            // 2. Select all <use> elements targeting #pr25
            // Using the attribute selector [href="#pr25"] ensures you only hit the right ones
            const useElements = document.querySelectorAll('use[href="#pr25"]');
            
            // 3. Loop and update the 'x' attribute
            useElements.forEach((el, index) => {
                if (xPositions[index] !== undefined) {
                    // We use setAttribute for x, y, href, etc.
                    el.setAttribute('x', xPositions[index]);
                }
            });
   */ -->
   
   <!-- Waypoint 250,150-->
   <use href="#wp" x="250" y="150" />
   <text x="250" y="150" class="wp-text">27</text>

   <!-- Gràfic principal -->
   <!-- Eliminem linia superior : line x1="95" y1="10" x2="1000" y2="10" stroke="black" stroke-width="1" /-->
   <line x1="95" y1="480" x2="980" y2="480" stroke="black" stroke-width="1" />
   <line x1="100" y1="20" x2="100" y2="485" stroke="black" stroke-width="1" />
   <line x1="980" y1="20" x2="980" y2="485" stroke="black" stroke-width="1" />
   <text x="90" y="480" font-family="Monospace" fill="black" font-size="12" font-weight="black" text-anchor="end">0</text>

   <!-- Sortida -->
   <circle cx="100" cy="20" r="16" fill="#404040" stroke="black" stroke-width="1" />
   <path d="M 92 12 
            L 92 28 
            L 108 20
            Z" 
         fill="lime" />
   <text x="120" y="36" font-family="Impact" fill="black" font-size="16" text-anchor="start">Vinaròs</text>
   <text x="100" y="500" fill="black" font-size="12" font-weight="black" text-anchor="middle">0</text>
   <!-- Meta -->
   <circle cx="980" cy="20" r="16" fill="url(#escacs)" stroke="black" stroke-width="1" />
   <text x="960" y="36" font-family="Impact" fill="black" font-size="16" text-anchor="end">Ulldecona</text>
   <text x="980" y="500" fill="black" font-size="12" font-weight="black" text-anchor="middle">14.7</text>
   
   <!-- Marques verticals -->
   <!-- line x1="95" y1="10" x2="1000" y2="10" stroke="black" stroke-width="1" /-->
      
   
   Sorry, your browser does not support inline SVG.
</svg> 
 
</body>
</html>
<!--
Notes
=====
Dades: Per construir el gràfic s'ha de coneixer l'alçada màxima, la mínima i els kms
Dimensions: Fixes, 240 alt x 400 ample
Marques horitzontals: 
   - Sempre entre les mínimes i les 20 marques màxim
   - Les marques seran generalment d'1km, excepte que la ruta sigui molt llarga; 
      Fins a 20 kms, 1 km/marca, més de 20; 2 kms/marca... de 40; 5 k/m... de 100; 10... de 200; 20... de 400; 50... de 1000;100.
      x_escala_rules = [ {"fins_km": 20; "km_per_marca": 1}, {"fins_km": 40; "km_per_marca": 2}, {"fins_km": 100; "km_per_marca": 5}, ... ]
Etiquetes horitzontals: 
   - Sempre es marcarà el 0 i l'últim km. 
   - Si l'últim km pot tapar l'anterior punt km, llavors no es posa l'anterior
   - La resta de punts km es posen o bé
Marques verticals:
   - Sempre entre les 6 i les 10 marques màxim
   - Sempre es deixarà una cota sencera per sota l'alçada mínima i 4 per sobre de la màxima
   - Dit d'una altra manera, la gràfica transcorrerà entre el 5% i el 55% de la graella. La resta són marge 0-5% i 95-100%, waypoints 55-75% i per parcials d'etapa 75-95%
   - Per tant, si alçada màxima - mínima = alt_diff_perfil ; alt_escala = 2 x alt_diff_perfil
   - Ara bé, hi haurà una alt_escala mínima; ja que si la alt_diff_perfil és baixa per ser etapa plana, no dibuixarem puntes en una etapa plana
      Fins a 125m diff, 25m/marca. Fins a 250m diff, 50m/marca. Fins a 500, 100. Fins a 1000, 200. Fins a 2000, 400. Fins a 5000, 1000.

-->
